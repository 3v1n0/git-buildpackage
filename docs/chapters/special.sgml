    <chapter id="gbp.special">
    <title>Special usage cases</title>
    <sect1 id="gbp.special.dfsgfree">
    <title>Handling non-DFSG clean upstream sources</title>
    <para>If you have to handle non DFSG clean upstream sources you can use a
    different branch which you have to create once:
    <screen>
&gitcmd; branch dfsg_clean upstream
    </screen>
    <para>
    This creates the <emphasis>dfsg_clean</emphasis> branch from the tip of
    your <emphasis>upstream</emphasis> branch.  Then, when importing a new
    upstream version, you import the new version on the
    <emphasis>upstream</emphasis> branch as usual and just don't merge to the
    master branch by default:
    </para>
    <screen>
&git-import-orig; --no-merge nondfsg-clean-package_10.4.orig.tar.gz
&gitcmd; tag 10.4
    </screen>
    <para>
    After the import you can switch to the dfsg branch and get the newly
    imported changes from the upstream branch:
    </para>
    <screen>
&gitcmd; checkout dfsg_clean
&gitcmd; pull . upstream
    </screen>
    <para>
    Now make this dfsg clean (preverably by a cleanup script), commit your changes and merge to the master branch:
    </para>
    <screen>
cleanup-script.sh
&gitcmd; commit -a -m "Make source dfsg clean"
&gitcmd; tag 10.4.dfsg
&gitcmd; checkout master
&gitcmd; pull . dfsg_clean
    </screen>

    <sect1 id="gbp.special.nmus">
    <title>Importing NMUs</title>
    <para>
    First create a branch that holds the NMUs once:
    </para>
    <screen>
&gitcmd; <option>branch</option> <replaceable>nmu</replaceable>
    </screen>
    <para>
    To import an NMU instead of a new upstream version simply import the
    unpacked NUMs source tree into your repository:
    </para>
    <screen>
&gitcmd; checkout master
&git-import-orig; -u 10-1.1 --upstream-branch=nmu /path/to/nmu-10/
    </screen>
    <para>
    This will import the NMU on the <emphasis>nmu</emphasis> branch instead of
    the <emphasis>upstream</emphasis> branch but merge the changes to the
    <emphasis>master</emphasis> branch as usual.
    </para>
    </sect1>

    <sect1 id="gbp.special.pbuilder">
    <title>Using &pbuilder;</title>
    <para>
    Since pbuilder use different command line arguments than
    &debuild; and &dpkg-buildpackage; we have to use a small script that's
    invoked by &git-buildpackage;:
<programlisting>
cat &lt;&lt;EOF &gt;/usr/local/bin/git-pbuilder
#!/bin/sh
# pass all options to dpkg-buildpackage:
pdebuild --debbuildopts "-i\.git -I.git $*"
EOF
chmod a+x /usr/local/bin/git-pbuilder
</programlisting>

    Furthermore we need a different clean command, since &pdebuildcmd;
    <option>clean</option> means something different than &debuildcmd;
    <option>clean</option>. We could put all this on the command line, but
    let's put it into the config file to safe typing:

<programlisting>
cat &lt;&lt;EOF &gt; <filename>~/.gbp.conf</filename>
[DEFAULT]
# tell git-buildpackage howto clean the source tree
cleaner = fakeroot debian/rules clean
# this is how we invoke pbuilder, arguments passed to git-buildpackage will be
# passed to dpkg-buildpackge in the chroot
builder = /usr/local/bin/git-pbuilder
</programlisting>
	
     Invoking &git-buildpackage; will now invoke &pdebuildcmd;</para>
     <para>
     If you don't want this for all your invocations of &git-buildpackage; you can instead
     put this into <filename>.git/gbp.conf</filename> in one of your &git; repositories.
    </para>

    <sect1 id="gbp.special.hacking">
    <title>Working on random packages</title>
    <para>
    Whenever you need to work on an arbitrary Debian package you can check it
    right into &git;:
<programlisting>
apt-get source --download-only <filename>package</filename>
git-import-dsc <filename>package</filename>*.dsc
cd <filename>package</filename>
git-branch debian
</programlisting>
    <para>
    This puts the orig.tar.gz onto the <emphasis>upstream</emphasis> branch and
    the Debian patch onto branch <emphasis>debian</emphasis>. Now you can
    easily modify the package on the master branch, revert changes you made,
    create other branches for testing, see what changes you made, etc.. When
    finished just do</para>
<programlisting>
git-commit -a
git-diff debian --
</programlisting>
    <para>
    to get a nice patch that can be submitted to the Debian BTS.
    </para>
    </sect1>
</chapter>
